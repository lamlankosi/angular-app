import type { Scale } from '../../scale/scale';
import type { ChartAxis, ChartAxisLabelFlipFlag } from '../chartAxis';
import type { AxisInterval } from './axisInterval';
import type { TickInterval } from './axisTick';
import type { TickDatum } from './axisUtil';
import { NiceMode } from './axisUtil';
export interface TickData<D = any> {
    tickDomain: D[];
    rawTicks: D[];
    fractionDigits: number;
    ticks: TickDatum[];
    niceDomain?: D[];
}
export interface TickGenerationParams<D = any> {
    domain: D[];
    primaryTickCount: number | undefined;
    visibleRange: [number, number];
    niceMode: NiceMode;
    parallelFlipRotation: number;
    regularFlipRotation: number;
    labelX: number;
    sideFlag: ChartAxisLabelFlipFlag;
}
export interface TickGenerationResult<D = any> {
    tickData: TickData<D>;
    primaryTickCount?: number;
    combinedRotation: number;
    textBaseline: CanvasTextBaseline;
    textAlign: CanvasTextAlign;
}
export interface TickGenerationAxis<S extends Scale<D, number, TickInterval<S>>, D> {
    readonly range: [number, number];
    readonly reverse: boolean;
    readonly scale: S;
    readonly label: ChartAxis['label'];
    readonly interval: AxisInterval<S>;
    readonly defaultTickMinSpacing: number;
    readonly inRange: ChartAxis['inRange'];
    formatTick(value: any, index: number, domain: D[], fractionDigits?: number, formatter?: (datum: any) => string): string;
}
export declare class AxisTickGenerator<S extends Scale<D, number, TickInterval<S>>, D> {
    private readonly axis;
    constructor(axis: TickGenerationAxis<S, D>);
    private estimateTickCount;
    private filterTicks;
    generateTicks({ domain, primaryTickCount, visibleRange, niceMode, parallelFlipRotation, regularFlipRotation, labelX, sideFlag, }: TickGenerationParams<D>): TickGenerationResult<D>;
    private getTickStrategies;
    private createTickData;
    private getTicks;
}
